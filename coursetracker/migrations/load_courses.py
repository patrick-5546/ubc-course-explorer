# Generated by Django 3.1.13 on 2021-07-21 23:32

import json
import os

from django.db import IntegrityError, migrations, transaction

from .ubc_course_explorer_data.update_data import (
    AVAILABLE_COURSES_FN,
    COURSE_INFORMATION_FN,
    COURSE_STATISTICS_FN,
    GRADE_DISTRIBUTIONS_FN,
    PROFESSOR_INFORMATION_FN,
    TEACHING_TEAM_FN
)

DATA_DIR_PATH = os.path.join(os.path.join('coursetracker', 'migrations'), 'ubc_course_explorer_data')


def load_courses_into_db(apps, schema_editor):
    '''Saves all courses in AVAIL_COURSES to the database.'''
    # We can't import the Course model directly as it may be a newer
    # version than this migration expects. We use the historical version.
    Course = apps.get_model('coursetracker', 'Course')

    print('')  # so that print statements start on new line
    load_courses(Course)


def load_courses(Course):
    avail_courses, course_info, course_stats, grade_distrs, prof_info, teaching_team = load_data_files()
    for subject, course_labels in avail_courses.items():
        print(f"\tLoading database with courses in {subject}")

        for course_label in course_labels:
            save_course_instance(Course, f"{subject} {course_label}", course_info, course_stats, grade_distrs,
                                 prof_info, teaching_team)


class Migration(migrations.Migration):

    # manually set to the last automatically generated migration (the ones that start with numbers)
    dependencies = [
        ('coursetracker', '0018_course_prerequisite_tree'),
    ]

    operations = [
        migrations.RunPython(load_courses_into_db)
    ]


def load_data_files():
    '''Loads the data files into global variables.'''
    return (_load_json(AVAILABLE_COURSES_FN), _load_json(COURSE_INFORMATION_FN),
            _load_json(COURSE_STATISTICS_FN), _load_json(GRADE_DISTRIBUTIONS_FN),
            _load_json(PROFESSOR_INFORMATION_FN), _load_json(TEACHING_TEAM_FN))


def _load_json(filename):
    '''Returns the objects stored in a json file.'''
    with open(os.path.join(DATA_DIR_PATH, filename), 'r') as json_file:
        return json.load(json_file)


def save_course_instance(Course, course_name, course_info, course_stats, grade_distrs, prof_info, teaching_team):
    '''Creates and save a Course object to the database.

    Inputs:
        - Course (model)
        - course_name (str): all caps, may have a detail (i.e., APSC 496D), or not (i.e., MATH 210)
        - course_info, course_stats, grade_distrs, prof_info, teaching_team: read from json files; see the data
          repository/submodule and its scraper files for more information
    '''
    stats = course_stats[course_name]
    avg = stats['average']
    avg5 = stats['average_past_5_yrs']
    stdev = stats['stdev']
    minavg = stats['min_course_avg']
    maxavg = stats['max_course_avg']
    # print(stats)

    distribution = grade_distrs[course_name][0]  # first element in list will be from most recent term
    grades = _get_grades_str(distribution['grades'])
    term = f"{distribution['year']}{distribution['session']}"
    name = distribution['course_title']  # more up to date than in stats, as it is from the most recent term
    # print(distribution)

    # the source for course_info does not have details
    # there are 4 characters in the number/detail if there is a detail
    subject, course = course_name.split(' ')
    course_name_no_detail = course_name[:-1] if len(course) == 4 else course_name
    info = course_info[course_name_no_detail] if course_name_no_detail in course_info else {}
    cred = info['cred'] if 'cred' in info and info['cred'] is not None else 'N/A'
    desc = info['desc'] if 'desc' in info and info['desc'] is not None else 'N/A'
    prer = info['prer'] if 'prer' in info and info['prer'] is not None else 'N/A'
    crer = info['crer'] if 'crer' in info and info['crer'] is not None else 'N/A'
    preq_tree = _create_preq_tree_str(course_name_no_detail, course_info)
    # print(info)

    link = ('https://courses.students.ubc.ca/cs/courseschedule?pname=subjarea&tname=subj-course&'
            f"dept={subject}&course={course}")

    sections_teaching_team = teaching_team[course_name] if course_name in teaching_team else {}
    prof_ratings = _get_prof_ratings_str(sections_teaching_team, prof_info)
    sections_teaching_team = json.dumps(sections_teaching_team)  # convert to json string after using

    try:
        with transaction.atomic():
            Course.objects.create(course_name=course_name, average=avg, five_year_average=avg5, lowest_average=minavg,
                                  highest_average=maxavg, standard_deviation=stdev, distribution=grades,
                                  distribution_term=term, sub_name=name, number_of_credits=cred,
                                  course_description=desc, prerequistes_description=prer, corequisites_description=crer,
                                  course_link=link, sections_teaching_team=sections_teaching_team,
                                  professor_ratings=prof_ratings, prerequisite_tree=preq_tree)
    except IntegrityError:
        print(f"\t\tCould not save {course_name} into database")
        pass


def _get_grades_str(distribution_dict):
    '''Returns a json string of the grade distribution list. There are 11 elements, in the following order:
        [<50%, 50-54%, 55-59%, 60-63%, 64-67%, 68-71%, 72-75%, 76-79%, 80-84%, 85-89%, 90-100%]
    '''
    grades = []

    # distribution_dict.values() is already in increasing order, except '<50%' is at the end
    #   - might be because it doesn't start with a number
    distr_dict_vals = list(distribution_dict.values())
    grades.append(distr_dict_vals[-1])
    grades.extend(distr_dict_vals[:-1])

    return json.dumps(grades)


def _get_prof_ratings_str(sections_teaching_team, prof_info):
    '''Returns a json string of the professor ratings list. See _append_prof_rating() for the format of each element in
    this list.
    '''
    teaching_team_list = _get_teaching_team_list(sections_teaching_team)
    prof_ratings = []
    for full_name in teaching_team_list:
        # full_name might have middle name, which is not in prof_info (from different sources)
        name_sections = full_name.split(' ')
        name = f"{name_sections[0]} {name_sections[-1]}"

        # not in prof_info if not a professor or professor information not available
        prof_name_info_list = prof_info[name] if name in prof_info else []
        if len(prof_name_info_list) == 1:
            _append_prof_rating(prof_ratings, full_name, prof_name_info_list[0])
        else:
            # there are multiple professor information entries under the same name, may or may not be the same prof
            for prof_name_info in prof_name_info_list:
                _append_prof_rating(prof_ratings, full_name, prof_name_info, is_same_name=True)

    return json.dumps(prof_ratings)


def _get_teaching_team_list(sections_teaching_team):
    '''Returns an alphabetical list of all teaching team members in sections_teaching_team.

    Inputs:
        - sections_teaching_team (dict): {section number: teaching team for that section (list)}
    '''
    teaching_team_list = []
    for _, section_teaching_team_list in sections_teaching_team.items():
        new_teaching_team_list = list(set(section_teaching_team_list) - set(teaching_team_list))
        teaching_team_list.extend(new_teaching_team_list)

    return sorted(teaching_team_list)


def _append_prof_rating(prof_ratings, prof_name, prof_name_info, is_same_name=False):
    '''Appends a list: [professor name, overall rating, number of ratings] to prof_ratings.
        - If is_same_name == True, adds the professor's department to their name
            - This is required because there may be multiple prof_name_info sections for a name
                - Either the professor was labelled under two deparments, or there are professors with the same name
                - Thus, the department is used to identify if the professor info sections are for the same person
                    - For example: 'David Miller (Business)' and 'David Miller (Marketing)' is probably the same person
    '''
    prof_key = prof_name if not is_same_name else f"{prof_name} ({prof_name_info['tDept']})"
    prof_ratings.append([prof_key, prof_name_info['overall_rating'], prof_name_info['tNumRatings']])


def _create_preq_tree_str(course_name, course_info):
    return json.dumps(_create_preq_tree(course_name, course_info))


def _create_preq_tree(course_name, course_info):
    '''
    Receives a Course module and course_info dictionary as parameters, and returns a prerequisite tree dictionary
    This includes not only the immediate prequisites of the paramater, but also all prerequisites
    for all courses connected.

    For example, MATH 200 requires MATH 150, and MATH 101.
        - Additionally, MATH 150 requires MATH 125 (MATH 101 AND MATH 125 have no prequisites).
        ->{'MATH 150': {'MATH 125': {}, 'MATH 101': {} }}
    '''
    immediate_prerequisites = course_info[course_name]['preq'] \
        if course_name in course_info and 'preq' in course_info[course_name] else {}

    if not immediate_prerequisites:
        return {}
    else:
        preq_tree = {}
        for preq_course in immediate_prerequisites:
            preq_tree[preq_course] = _create_preq_tree(preq_course, course_info)

        return preq_tree
